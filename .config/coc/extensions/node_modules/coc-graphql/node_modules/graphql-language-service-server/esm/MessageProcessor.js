import mkdirp from 'mkdirp';
import { readFileSync, existsSync, writeFileSync } from 'node:fs';
import { writeFile } from 'node:fs/promises';
import * as path from 'node:path';
import glob from 'fast-glob';
import { URI } from 'vscode-uri';
import { FileChangeTypeKind, Range, Position, } from 'graphql-language-service';
import { GraphQLLanguageService } from './GraphQLLanguageService';
import { getGraphQLCache } from './GraphQLCache';
import { parseDocument } from './parseDocument';
import { printSchema, visit, parse } from 'graphql';
import { tmpdir } from 'node:os';
import { ConfigEmptyError, ConfigInvalidError, ConfigNotFoundError, LoaderNoResultError, ProjectNotFoundError, } from 'graphql-config';
import { DEFAULT_SUPPORTED_EXTENSIONS, } from './constants';
const configDocLink = 'https://www.npmjs.com/package/graphql-language-service-server#user-content-graphql-configuration-file';
function toPosition(position) {
    return new Position(position.line, position.character);
}
export class MessageProcessor {
    constructor({ logger, fileExtensions, graphqlFileExtensions, loadConfigOptions, config, parser, tmpDir, connection, }) {
        var _a;
        this._textDocumentCache = new Map();
        this._isInitialized = false;
        this._isGraphQLConfigMissing = null;
        this._willShutdown = false;
        this._schemaCacheInit = false;
        this._rootPath = process.cwd();
        this._connection = connection;
        this._logger = logger;
        this._graphQLConfig = config;
        this._parser = (text, uri) => {
            const p = parser !== null && parser !== void 0 ? parser : parseDocument;
            return p(text, uri, fileExtensions, graphqlFileExtensions, this._logger);
        };
        this._tmpDir = tmpDir || tmpdir();
        this._tmpDirBase = path.join(this._tmpDir, 'graphql-language-service');
        this._tmpUriBase = URI.file(this._tmpDirBase).toString();
        this._loadConfigOptions = { legacy: true, ...loadConfigOptions };
        if (loadConfigOptions.extensions &&
            ((_a = loadConfigOptions.extensions) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            this._extensions = loadConfigOptions.extensions;
        }
        if (!existsSync(this._tmpDirBase)) {
            void mkdirp(this._tmpDirBase);
        }
    }
    get connection() {
        return this._connection;
    }
    set connection(connection) {
        this._connection = connection;
    }
    async handleInitializeRequest(params, _token, configDir) {
        if (!params) {
            throw new Error('`params` argument is required to initialize.');
        }
        const serverCapabilities = {
            capabilities: {
                workspaceSymbolProvider: true,
                documentSymbolProvider: true,
                completionProvider: {
                    resolveProvider: true,
                    triggerCharacters: [' ', ':', '$', '(', '@'],
                },
                definitionProvider: true,
                textDocumentSync: 1,
                hoverProvider: true,
                workspace: {
                    workspaceFolders: {
                        supported: true,
                        changeNotifications: true,
                    },
                },
            },
        };
        this._rootPath = configDir
            ? configDir.trim()
            : params.rootUri || this._rootPath;
        if (!this._rootPath) {
            this._logger.warn('no rootPath configured in extension or server, defaulting to cwd');
        }
        if (!serverCapabilities) {
            throw new Error('GraphQL Language Server is not initialized.');
        }
        this._logger.info(JSON.stringify({
            type: 'usage',
            messageType: 'initialize',
        }));
        return serverCapabilities;
    }
    async _updateGraphQLConfig() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const settings = await this._connection.workspace.getConfiguration({
            section: 'graphql-config',
        });
        const vscodeSettings = await this._connection.workspace.getConfiguration({
            section: 'vscode-graphql',
        });
        if (settings === null || settings === void 0 ? void 0 : settings.dotEnvPath) {
            require('dotenv').config({ path: settings.dotEnvPath });
        }
        this._settings = { ...settings, ...vscodeSettings };
        const rootDir = ((_b = (_a = this._settings) === null || _a === void 0 ? void 0 : _a.load) === null || _b === void 0 ? void 0 : _b.rootDir.length)
            ? (_d = (_c = this._settings) === null || _c === void 0 ? void 0 : _c.load) === null || _d === void 0 ? void 0 : _d.rootDir
            : this._rootPath;
        this._rootPath = rootDir;
        this._loadConfigOptions = {
            ...Object.keys((_f = (_e = this._settings) === null || _e === void 0 ? void 0 : _e.load) !== null && _f !== void 0 ? _f : {}).reduce((agg, key) => {
                var _a;
                const value = (_a = this._settings) === null || _a === void 0 ? void 0 : _a.load[key];
                if (value === undefined || value === null) {
                    delete agg[key];
                }
                return agg;
            }, (_g = this._settings.load) !== null && _g !== void 0 ? _g : {}),
            rootDir,
        };
        try {
            this._graphQLCache = await getGraphQLCache({
                parser: this._parser,
                loadConfigOptions: this._loadConfigOptions,
                logger: this._logger,
            });
            this._languageService = new GraphQLLanguageService(this._graphQLCache, this._logger);
            if (this._graphQLConfig || ((_h = this._graphQLCache) === null || _h === void 0 ? void 0 : _h.getGraphQLConfig)) {
                const config = (_j = this._graphQLConfig) !== null && _j !== void 0 ? _j : this._graphQLCache.getGraphQLConfig();
                await this._cacheAllProjectFiles(config);
            }
            this._isInitialized = true;
        }
        catch (err) {
            this._handleConfigError({ err });
        }
    }
    _handleConfigError({ err }) {
        var _a;
        if (err instanceof ConfigNotFoundError || err instanceof ConfigEmptyError) {
            this._isGraphQLConfigMissing = true;
            this._logConfigError(err.message);
        }
        else if (err instanceof ProjectNotFoundError) {
            this._logConfigError('Project not found for this file - make sure that a schema is present');
        }
        else if (err instanceof ConfigInvalidError) {
            this._isGraphQLConfigMissing = true;
            this._logConfigError(`Invalid configuration\n${err.message}`);
        }
        else if (err instanceof LoaderNoResultError) {
            this._isGraphQLConfigMissing = true;
            this._logConfigError(err.message);
            return;
        }
        else {
            this._isGraphQLConfigMissing = true;
            this._logConfigError((_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString());
        }
    }
    _logConfigError(errorMessage) {
        this._logger.error('WARNING: graphql-config error, only highlighting is enabled:\n' +
            errorMessage +
            `\nfor more information on using 'graphql-config' with 'graphql-language-service-server', \nsee the documentation at ${configDocLink}`);
    }
    async _isGraphQLConfigFile(uri) {
        var _a, _b, _c, _d;
        const configMatchers = ['graphql.config', 'graphqlrc', 'graphqlconfig'];
        if ((_c = (_b = (_a = this._settings) === null || _a === void 0 ? void 0 : _a.load) === null || _b === void 0 ? void 0 : _b.fileName) === null || _c === void 0 ? void 0 : _c.length) {
            configMatchers.push(this._settings.load.fileName);
        }
        const fileMatch = configMatchers
            .filter(Boolean)
            .some(v => { var _a; return (_a = uri.match(v)) === null || _a === void 0 ? void 0 : _a.length; });
        if (fileMatch) {
            return fileMatch;
        }
        if ((_d = uri.match('package.json')) === null || _d === void 0 ? void 0 : _d.length) {
            const graphqlConfig = await import(URI.parse(uri).fsPath);
            return Boolean(graphqlConfig === null || graphqlConfig === void 0 ? void 0 : graphqlConfig.graphql);
        }
        return false;
    }
    async handleDidOpenOrSaveNotification(params) {
        var _a, _b;
        const isGraphQLConfigFile = await this._isGraphQLConfigFile(params.textDocument.uri);
        try {
            if (!this._isInitialized || !this._graphQLCache) {
                if (this._isGraphQLConfigMissing === true && !isGraphQLConfigFile) {
                    return null;
                }
                await this._updateGraphQLConfig();
            }
        }
        catch (err) {
            this._logger.error(String(err));
        }
        if (!(params === null || params === void 0 ? void 0 : params.textDocument)) {
            throw new Error('`textDocument` argument is required.');
        }
        const { textDocument } = params;
        const { uri } = textDocument;
        const diagnostics = [];
        let contents = [];
        const text = 'text' in textDocument && textDocument.text;
        if (text) {
            contents = this._parser(text, uri);
            await this._invalidateCache(textDocument, uri, contents);
        }
        else {
            if (isGraphQLConfigFile) {
                this._logger.info('updating graphql config');
                await this._updateGraphQLConfig();
                return { uri, diagnostics: [] };
            }
            return null;
        }
        if (!this._graphQLCache) {
            return { uri, diagnostics };
        }
        try {
            const project = this._graphQLCache.getProjectForFile(uri);
            if (this._isInitialized &&
                ((_b = (_a = project === null || project === void 0 ? void 0 : project.extensions) === null || _a === void 0 ? void 0 : _a.languageService) === null || _b === void 0 ? void 0 : _b.enableValidation) !== false) {
                await Promise.all(contents.map(async ({ query, range }) => {
                    const results = await this._languageService.getDiagnostics(query, uri, this._isRelayCompatMode(query));
                    if (results && results.length > 0) {
                        diagnostics.push(...processDiagnosticsMessage(results, query, range));
                    }
                }));
            }
            this._logger.log(JSON.stringify({
                type: 'usage',
                messageType: 'textDocument/didOpenOrSave',
                projectName: project === null || project === void 0 ? void 0 : project.name,
                fileName: uri,
            }));
        }
        catch (err) {
            this._handleConfigError({ err, uri });
        }
        return { uri, diagnostics };
    }
    async handleDidChangeNotification(params) {
        var _a, _b, _c;
        if (this._isGraphQLConfigMissing ||
            !this._isInitialized ||
            !this._graphQLCache) {
            return null;
        }
        if (!((_a = params === null || params === void 0 ? void 0 : params.textDocument) === null || _a === void 0 ? void 0 : _a.uri) || !params.contentChanges) {
            throw new Error('`textDocument.uri` and `contentChanges` arguments are required.');
        }
        const { textDocument, contentChanges } = params;
        const { uri } = textDocument;
        const project = this._graphQLCache.getProjectForFile(uri);
        try {
            const contentChange = contentChanges.at(-1);
            const contents = this._parser(contentChange.text, uri);
            await this._invalidateCache(textDocument, uri, contents);
            const cachedDocument = this._getCachedDocument(uri);
            if (!cachedDocument) {
                return null;
            }
            await this._updateFragmentDefinition(uri, contents);
            await this._updateObjectTypeDefinition(uri, contents);
            const diagnostics = [];
            if (((_c = (_b = project === null || project === void 0 ? void 0 : project.extensions) === null || _b === void 0 ? void 0 : _b.languageService) === null || _c === void 0 ? void 0 : _c.enableValidation) !== false) {
                await Promise.all(contents.map(async ({ query, range }) => {
                    const results = await this._languageService.getDiagnostics(query, uri, this._isRelayCompatMode(query));
                    if (results && results.length > 0) {
                        diagnostics.push(...processDiagnosticsMessage(results, query, range));
                    }
                }));
            }
            this._logger.log(JSON.stringify({
                type: 'usage',
                messageType: 'textDocument/didChange',
                projectName: project === null || project === void 0 ? void 0 : project.name,
                fileName: uri,
            }));
            return { uri, diagnostics };
        }
        catch (err) {
            this._handleConfigError({ err, uri });
            return { uri, diagnostics: [] };
        }
    }
    async handleDidChangeConfiguration(_params) {
        await this._updateGraphQLConfig();
        this._logger.log(JSON.stringify({
            type: 'usage',
            messageType: 'workspace/didChangeConfiguration',
        }));
        return {};
    }
    handleDidCloseNotification(params) {
        if (!this._isInitialized || !this._graphQLCache) {
            return;
        }
        if (!(params === null || params === void 0 ? void 0 : params.textDocument)) {
            throw new Error('`textDocument` is required.');
        }
        const { textDocument } = params;
        const { uri } = textDocument;
        if (this._textDocumentCache.has(uri)) {
            this._textDocumentCache.delete(uri);
        }
        const project = this._graphQLCache.getProjectForFile(uri);
        this._logger.log(JSON.stringify({
            type: 'usage',
            messageType: 'textDocument/didClose',
            projectName: project === null || project === void 0 ? void 0 : project.name,
            fileName: uri,
        }));
    }
    handleShutdownRequest() {
        this._willShutdown = true;
    }
    handleExitNotification() {
        process.exit(this._willShutdown ? 0 : 1);
    }
    validateDocumentAndPosition(params) {
        var _a;
        if (!((_a = params === null || params === void 0 ? void 0 : params.textDocument) === null || _a === void 0 ? void 0 : _a.uri) || !params.position) {
            throw new Error('`textDocument.uri` and `position` arguments are required.');
        }
    }
    async handleCompletionRequest(params) {
        if (!this._isInitialized || !this._graphQLCache) {
            return [];
        }
        this.validateDocumentAndPosition(params);
        const { textDocument, position } = params;
        const cachedDocument = this._getCachedDocument(textDocument.uri);
        if (!cachedDocument) {
            return [];
        }
        const found = cachedDocument.contents.find(content => {
            const currentRange = content.range;
            if (currentRange === null || currentRange === void 0 ? void 0 : currentRange.containsPosition(toPosition(position))) {
                return true;
            }
        });
        if (!found) {
            return [];
        }
        const { query, range } = found;
        if (range) {
            position.line -= range.start.line;
        }
        const result = await this._languageService.getAutocompleteSuggestions(query, toPosition(position), textDocument.uri);
        const project = this._graphQLCache.getProjectForFile(textDocument.uri);
        this._logger.log(JSON.stringify({
            type: 'usage',
            messageType: 'textDocument/completion',
            projectName: project === null || project === void 0 ? void 0 : project.name,
            fileName: textDocument.uri,
        }));
        return { items: result, isIncomplete: false };
    }
    async handleHoverRequest(params) {
        if (!this._isInitialized || !this._graphQLCache) {
            return { contents: [] };
        }
        this.validateDocumentAndPosition(params);
        const { textDocument, position } = params;
        const cachedDocument = this._getCachedDocument(textDocument.uri);
        if (!cachedDocument) {
            return { contents: [] };
        }
        const found = cachedDocument.contents.find(content => {
            const currentRange = content.range;
            if (currentRange === null || currentRange === void 0 ? void 0 : currentRange.containsPosition(toPosition(position))) {
                return true;
            }
        });
        if (!found) {
            return { contents: [] };
        }
        const { query, range } = found;
        if (range) {
            position.line -= range.start.line;
        }
        const result = await this._languageService.getHoverInformation(query, toPosition(position), textDocument.uri, { useMarkdown: true });
        return {
            contents: result,
        };
    }
    async handleWatchedFilesChangedNotification(params) {
        if (this._isGraphQLConfigMissing ||
            !this._isInitialized ||
            !this._graphQLCache) {
            return null;
        }
        return Promise.all(params.changes.map(async (change) => {
            var _a, _b;
            if (this._isGraphQLConfigMissing ||
                !this._isInitialized ||
                !this._graphQLCache) {
                this._logger.warn('No cache available for handleWatchedFilesChanged');
                return;
            }
            if (change.type === FileChangeTypeKind.Created ||
                change.type === FileChangeTypeKind.Changed) {
                const { uri } = change;
                const text = readFileSync(URI.parse(uri).fsPath, 'utf-8');
                const contents = this._parser(text, uri);
                await this._updateFragmentDefinition(uri, contents);
                await this._updateObjectTypeDefinition(uri, contents);
                try {
                    const project = this._graphQLCache.getProjectForFile(uri);
                    if (project) {
                        await this._updateSchemaIfChanged(project, uri);
                    }
                    let diagnostics = [];
                    if (((_b = (_a = project === null || project === void 0 ? void 0 : project.extensions) === null || _a === void 0 ? void 0 : _a.languageService) === null || _b === void 0 ? void 0 : _b.enableValidation) !== false) {
                        diagnostics = (await Promise.all(contents.map(async ({ query, range }) => {
                            const results = await this._languageService.getDiagnostics(query, uri, this._isRelayCompatMode(query));
                            if (results && results.length > 0) {
                                return processDiagnosticsMessage(results, query, range);
                            }
                            return [];
                        }))).reduce((left, right) => left.concat(right), diagnostics);
                    }
                    this._logger.log(JSON.stringify({
                        type: 'usage',
                        messageType: 'workspace/didChangeWatchedFiles',
                        projectName: project === null || project === void 0 ? void 0 : project.name,
                        fileName: uri,
                    }));
                    return { uri, diagnostics };
                }
                catch (err) {
                    this._handleConfigError({ err, uri });
                    return { uri, diagnostics: [] };
                }
            }
            if (change.type === FileChangeTypeKind.Deleted) {
                await this._graphQLCache.updateFragmentDefinitionCache(this._graphQLCache.getGraphQLConfig().dirpath, change.uri, false);
                await this._graphQLCache.updateObjectTypeDefinitionCache(this._graphQLCache.getGraphQLConfig().dirpath, change.uri, false);
            }
        }));
    }
    async handleDefinitionRequest(params, _token) {
        if (!this._isInitialized || !this._graphQLCache) {
            return [];
        }
        if (!(params === null || params === void 0 ? void 0 : params.textDocument) || !params.position) {
            throw new Error('`textDocument` and `position` arguments are required.');
        }
        const { textDocument, position } = params;
        const project = this._graphQLCache.getProjectForFile(textDocument.uri);
        if (project) {
            await this._cacheSchemaFilesForProject(project);
        }
        const cachedDocument = this._getCachedDocument(textDocument.uri);
        if (!cachedDocument) {
            return [];
        }
        const found = cachedDocument.contents.find(content => {
            const currentRange = content.range;
            if (currentRange === null || currentRange === void 0 ? void 0 : currentRange.containsPosition(toPosition(position))) {
                return true;
            }
        });
        if (!found) {
            return [];
        }
        const { query, range: parentRange } = found;
        if (parentRange) {
            position.line -= parentRange.start.line;
        }
        let result = null;
        try {
            result = await this._languageService.getDefinition(query, toPosition(position), textDocument.uri);
        }
        catch (_a) {
        }
        const inlineFragments = [];
        try {
            visit(parse(query), {
                FragmentDefinition(node) {
                    inlineFragments.push(node.name.value);
                },
            });
        }
        catch (_b) { }
        const formatted = result
            ? result.definitions.map(res => {
                const defRange = res.range;
                if (parentRange && res.name) {
                    const isInline = inlineFragments.includes(res.name);
                    const isEmbedded = DEFAULT_SUPPORTED_EXTENSIONS.includes(path.extname(textDocument.uri));
                    if (isInline && isEmbedded) {
                        const vOffset = parentRange.start.line;
                        defRange.setStart((defRange.start.line += vOffset), defRange.start.character);
                        defRange.setEnd((defRange.end.line += vOffset), defRange.end.character);
                    }
                }
                return {
                    uri: res.path,
                    range: defRange,
                };
            })
            : [];
        this._logger.log(JSON.stringify({
            type: 'usage',
            messageType: 'textDocument/definition',
            projectName: project === null || project === void 0 ? void 0 : project.name,
            fileName: textDocument.uri,
        }));
        return formatted;
    }
    async handleDocumentSymbolRequest(params) {
        if (!this._isInitialized || !this._graphQLCache) {
            return [];
        }
        if (!(params === null || params === void 0 ? void 0 : params.textDocument)) {
            throw new Error('`textDocument` argument is required.');
        }
        const { textDocument } = params;
        const cachedDocument = this._getCachedDocument(textDocument.uri);
        if (!(cachedDocument === null || cachedDocument === void 0 ? void 0 : cachedDocument.contents[0])) {
            return [];
        }
        if (this._settings.largeFileThreshold !== undefined &&
            this._settings.largeFileThreshold <
                cachedDocument.contents[0].query.length) {
            return [];
        }
        this._logger.log(JSON.stringify({
            type: 'usage',
            messageType: 'textDocument/documentSymbol',
            fileName: textDocument.uri,
        }));
        return this._languageService.getDocumentSymbols(cachedDocument.contents[0].query, textDocument.uri);
    }
    async handleWorkspaceSymbolRequest(params) {
        if (!this._isInitialized || !this._graphQLCache) {
            return [];
        }
        if (params.query !== '') {
            const documents = this._getTextDocuments();
            const symbols = [];
            await Promise.all(documents.map(async ([uri]) => {
                const cachedDocument = this._getCachedDocument(uri);
                if (!cachedDocument) {
                    return [];
                }
                const docSymbols = await this._languageService.getDocumentSymbols(cachedDocument.contents[0].query, uri);
                symbols.push(...docSymbols);
            }));
            return symbols.filter(symbol => (symbol === null || symbol === void 0 ? void 0 : symbol.name) && symbol.name.includes(params.query));
        }
        return [];
    }
    _getTextDocuments() {
        return Array.from(this._textDocumentCache);
    }
    async _cacheSchemaText(uri, text, version) {
        try {
            const contents = this._parser(text, uri);
            if (contents.length > 0) {
                await this._invalidateCache({ version, uri }, uri, contents);
                await this._updateObjectTypeDefinition(uri, contents);
            }
        }
        catch (err) {
            this._logger.error(String(err));
        }
    }
    async _cacheSchemaFile(_uri, project) {
        const uri = _uri.toString();
        const isFileUri = existsSync(uri);
        let version = 1;
        if (isFileUri) {
            const schemaUri = URI.file(path.join(project.dirpath, uri)).toString();
            const schemaDocument = this._getCachedDocument(schemaUri);
            if (schemaDocument) {
                version = schemaDocument.version++;
            }
            const schemaText = readFileSync(uri, 'utf8');
            await this._cacheSchemaText(schemaUri, schemaText, version);
        }
    }
    _getTmpProjectPath(project, prependWithProtocol = true, appendPath) {
        const baseDir = this._graphQLCache.getGraphQLConfig().dirpath;
        const workspaceName = path.basename(baseDir);
        const basePath = path.join(this._tmpDirBase, workspaceName);
        let projectTmpPath = path.join(basePath, 'projects', project.name);
        if (!existsSync(projectTmpPath)) {
            void mkdirp(projectTmpPath);
        }
        if (appendPath) {
            projectTmpPath = path.join(projectTmpPath, appendPath);
        }
        if (prependWithProtocol) {
            return URI.file(path.resolve(projectTmpPath)).toString();
        }
        return path.resolve(projectTmpPath);
    }
    async _cacheSchemaPath(uri, project) {
        try {
            const files = await glob(uri);
            if (files && files.length > 0) {
                await Promise.all(files.map(uriPath => this._cacheSchemaFile(uriPath, project)));
            }
            else {
                try {
                    await this._cacheSchemaFile(uri, project);
                }
                catch (_a) {
                }
            }
        }
        catch (_b) { }
    }
    async _cacheObjectSchema(pointer, project) {
        await Promise.all(Object.keys(pointer).map(async (schemaUri) => this._cacheSchemaPath(schemaUri, project)));
    }
    async _cacheArraySchema(pointers, project) {
        await Promise.all(pointers.map(async (schemaEntry) => {
            if (typeof schemaEntry === 'string') {
                await this._cacheSchemaPath(schemaEntry, project);
            }
            else if (schemaEntry) {
                await this._cacheObjectSchema(schemaEntry, project);
            }
        }));
    }
    async _cacheSchemaFilesForProject(project) {
        var _a, _b, _c, _d;
        const schema = project === null || project === void 0 ? void 0 : project.schema;
        const config = (_a = project === null || project === void 0 ? void 0 : project.extensions) === null || _a === void 0 ? void 0 : _a.languageService;
        const cacheSchemaFileForLookup = (_d = (_b = config === null || config === void 0 ? void 0 : config.cacheSchemaFileForLookup) !== null && _b !== void 0 ? _b : (_c = this === null || this === void 0 ? void 0 : this._settings) === null || _c === void 0 ? void 0 : _c.cacheSchemaFileForLookup) !== null && _d !== void 0 ? _d : false;
        if (cacheSchemaFileForLookup) {
            await this._cacheConfigSchema(project);
        }
        else if (typeof schema === 'string') {
            await this._cacheSchemaPath(schema, project);
        }
        else if (Array.isArray(schema)) {
            await this._cacheArraySchema(schema, project);
        }
        else if (schema) {
            await this._cacheObjectSchema(schema, project);
        }
    }
    async _cacheConfigSchema(project) {
        try {
            const schema = await this._graphQLCache.getSchema(project.name);
            if (schema) {
                let schemaText = printSchema(schema);
                const uri = this._getTmpProjectPath(project, true, 'generated-schema.graphql');
                const fsPath = this._getTmpProjectPath(project, false, 'generated-schema.graphql');
                schemaText = `# This is an automatically generated representation of your schema.\n# Any changes to this file will be overwritten and will not be\n# reflected in the resulting GraphQL schema\n\n${schemaText}`;
                const cachedSchemaDoc = this._getCachedDocument(uri);
                if (!cachedSchemaDoc) {
                    await writeFile(fsPath, schemaText, 'utf8');
                    await this._cacheSchemaText(uri, schemaText, 1);
                }
                if (cachedSchemaDoc) {
                    writeFileSync(fsPath, schemaText, 'utf8');
                    await this._cacheSchemaText(uri, schemaText, cachedSchemaDoc.version++);
                }
            }
        }
        catch (err) {
            this._logger.error(String(err));
        }
    }
    async _cacheDocumentFilesforProject(project) {
        try {
            const documents = await project.getDocuments();
            return Promise.all(documents.map(async (document) => {
                var _a;
                if (!document.location || !document.rawSDL) {
                    return;
                }
                let filePath = document.location;
                if (!path.isAbsolute(filePath)) {
                    filePath = path.join(project.dirpath, document.location);
                }
                const uri = URI.file(filePath).toString();
                const contents = this._parser(document.rawSDL, uri);
                if (!((_a = contents[0]) === null || _a === void 0 ? void 0 : _a.query)) {
                    return;
                }
                await this._updateObjectTypeDefinition(uri, contents);
                await this._updateFragmentDefinition(uri, contents);
                await this._invalidateCache({ version: 1, uri }, uri, contents);
            }));
        }
        catch (err) {
            this._logger.error(`invalid/unknown file in graphql config documents entry:\n '${project.documents}'`);
            this._logger.error(String(err));
        }
    }
    async _cacheAllProjectFiles(config) {
        if (config === null || config === void 0 ? void 0 : config.projects) {
            return Promise.all(Object.keys(config.projects).map(async (projectName) => {
                const project = config.getProject(projectName);
                await this._cacheSchemaFilesForProject(project);
                await this._cacheDocumentFilesforProject(project);
            }));
        }
    }
    _isRelayCompatMode(query) {
        return (query.includes('RelayCompat') || query.includes('react-relay/compat'));
    }
    async _updateFragmentDefinition(uri, contents) {
        const rootDir = this._graphQLCache.getGraphQLConfig().dirpath;
        await this._graphQLCache.updateFragmentDefinition(rootDir, uri, contents);
    }
    async _updateSchemaIfChanged(project, uri) {
        await Promise.all(this._unwrapProjectSchema(project).map(async (schema) => {
            const schemaFilePath = path.resolve(project.dirpath, schema);
            const uriFilePath = URI.parse(uri).fsPath;
            if (uriFilePath === schemaFilePath) {
                await this._graphQLCache.invalidateSchemaCacheForProject(project);
            }
        }));
    }
    _unwrapProjectSchema(project) {
        const projectSchema = project.schema;
        const schemas = [];
        if (typeof projectSchema === 'string') {
            schemas.push(projectSchema);
        }
        else if (Array.isArray(projectSchema)) {
            for (const schemaEntry of projectSchema) {
                if (typeof schemaEntry === 'string') {
                    schemas.push(schemaEntry);
                }
                else if (schemaEntry) {
                    schemas.push(...Object.keys(schemaEntry));
                }
            }
        }
        else {
            schemas.push(...Object.keys(projectSchema));
        }
        return schemas;
    }
    async _updateObjectTypeDefinition(uri, contents) {
        const rootDir = this._graphQLCache.getGraphQLConfig().dirpath;
        await this._graphQLCache.updateObjectTypeDefinition(rootDir, uri, contents);
    }
    _getCachedDocument(uri) {
        if (this._textDocumentCache.has(uri)) {
            const cachedDocument = this._textDocumentCache.get(uri);
            if (cachedDocument) {
                return cachedDocument;
            }
        }
        return null;
    }
    async _invalidateCache(textDocument, uri, contents) {
        var _a;
        if (this._textDocumentCache.has(uri)) {
            const cachedDocument = this._textDocumentCache.get(uri);
            if (cachedDocument &&
                textDocument &&
                (textDocument === null || textDocument === void 0 ? void 0 : textDocument.version) &&
                cachedDocument.version < textDocument.version) {
                return this._textDocumentCache.set(uri, {
                    version: textDocument.version,
                    contents,
                });
            }
        }
        return this._textDocumentCache.set(uri, {
            version: (_a = textDocument.version) !== null && _a !== void 0 ? _a : 0,
            contents,
        });
    }
}
function processDiagnosticsMessage(results, query, range) {
    const queryLines = query.split('\n');
    const totalLines = queryLines.length;
    const lastLineLength = queryLines[totalLines - 1].length;
    const lastCharacterPosition = new Position(totalLines, lastLineLength);
    const processedResults = results.filter(diagnostic => diagnostic.range.end.lessThanOrEqualTo(lastCharacterPosition));
    if (range) {
        const offset = range.start;
        return processedResults.map(diagnostic => ({
            ...diagnostic,
            range: new Range(new Position(diagnostic.range.start.line + offset.line, diagnostic.range.start.character), new Position(diagnostic.range.end.line + offset.line, diagnostic.range.end.character)),
        }));
    }
    return processedResults;
}
//# sourceMappingURL=MessageProcessor.js.map
import { parse, compileScript } from '@vue/compiler-sfc';
import { Position, Range } from 'graphql-language-service';
export function parseVueSFC(source) {
    const { errors, descriptor } = parse(source);
    if (errors.length !== 0) {
        return { type: 'error', errors };
    }
    let scriptBlock = null;
    try {
        scriptBlock = compileScript(descriptor, { id: 'foobar' });
    }
    catch (error) {
        if (error instanceof Error &&
            error.message === '[@vue/compiler-sfc] SFC contains no <script> tags.') {
            return {
                type: 'ok',
                scriptSetupAst: [],
                scriptAst: [],
                scriptOffset: 0,
            };
        }
        return { type: 'error', errors: [error] };
    }
    return {
        type: 'ok',
        scriptOffset: scriptBlock.loc.start.line - 1,
        scriptSetupAst: scriptBlock === null || scriptBlock === void 0 ? void 0 : scriptBlock.scriptSetupAst,
        scriptAst: scriptBlock === null || scriptBlock === void 0 ? void 0 : scriptBlock.scriptAst,
    };
}
export const vueParser = (text, uri, logger) => {
    const asts = [];
    const parseVueSFCResult = parseVueSFC(text);
    if (parseVueSFCResult.type === 'error') {
        logger.error(`Could not parse the vue file at ${uri} to extract the graphql tags:`);
        for (const error of parseVueSFCResult.errors) {
            logger.error(String(error));
        }
        return null;
    }
    if (parseVueSFCResult.scriptAst !== undefined) {
        asts.push(...parseVueSFCResult.scriptAst);
    }
    if (parseVueSFCResult.scriptSetupAst !== undefined) {
        asts.push(...parseVueSFCResult.scriptSetupAst);
    }
    const rangeMapper = range => {
        return new Range(new Position(range.start.line + parseVueSFCResult.scriptOffset, range.start.character), new Position(range.end.line + parseVueSFCResult.scriptOffset, range.end.character));
    };
    return { asts, rangeMapper };
};
//# sourceMappingURL=vue.js.map
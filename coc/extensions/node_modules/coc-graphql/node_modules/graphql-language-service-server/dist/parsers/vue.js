"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.vueParser = exports.parseVueSFC = void 0;
const compiler_sfc_1 = require("@vue/compiler-sfc");
const graphql_language_service_1 = require("graphql-language-service");
function parseVueSFC(source) {
    const { errors, descriptor } = (0, compiler_sfc_1.parse)(source);
    if (errors.length !== 0) {
        return { type: 'error', errors };
    }
    let scriptBlock = null;
    try {
        scriptBlock = (0, compiler_sfc_1.compileScript)(descriptor, { id: 'foobar' });
    }
    catch (error) {
        if (error instanceof Error &&
            error.message === '[@vue/compiler-sfc] SFC contains no <script> tags.') {
            return {
                type: 'ok',
                scriptSetupAst: [],
                scriptAst: [],
                scriptOffset: 0,
            };
        }
        return { type: 'error', errors: [error] };
    }
    return {
        type: 'ok',
        scriptOffset: scriptBlock.loc.start.line - 1,
        scriptSetupAst: scriptBlock === null || scriptBlock === void 0 ? void 0 : scriptBlock.scriptSetupAst,
        scriptAst: scriptBlock === null || scriptBlock === void 0 ? void 0 : scriptBlock.scriptAst,
    };
}
exports.parseVueSFC = parseVueSFC;
const vueParser = (text, uri, logger) => {
    const asts = [];
    const parseVueSFCResult = parseVueSFC(text);
    if (parseVueSFCResult.type === 'error') {
        logger.error(`Could not parse the vue file at ${uri} to extract the graphql tags:`);
        for (const error of parseVueSFCResult.errors) {
            logger.error(String(error));
        }
        return null;
    }
    if (parseVueSFCResult.scriptAst !== undefined) {
        asts.push(...parseVueSFCResult.scriptAst);
    }
    if (parseVueSFCResult.scriptSetupAst !== undefined) {
        asts.push(...parseVueSFCResult.scriptSetupAst);
    }
    const rangeMapper = range => {
        return new graphql_language_service_1.Range(new graphql_language_service_1.Position(range.start.line + parseVueSFCResult.scriptOffset, range.start.character), new graphql_language_service_1.Position(range.end.line + parseVueSFCResult.scriptOffset, range.end.character));
    };
    return { asts, rangeMapper };
};
exports.vueParser = vueParser;
//# sourceMappingURL=vue.js.map